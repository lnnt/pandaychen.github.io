---
layout: post
title: Bash 日常应用总结
subtitle: A Linux Bash Cookbook
date: 2022-06-10
author: pandaychen
header-img:
catalog: true
category: false
tags:
  - Bash
---

## 0x00 前言
本文汇总下笔者常用的Bash指令备份


##  0x01  BASH
1、批量查找文件内容<br>
主要使用`grep -rl`，如下面指令，查询当前目录下所有出现`yyyy`字符串的文件列表：
```bash
grep yyyy -rl --include="*.txt" ./
```

2、批量替换文件内容<br>
常用`sed`搭配`grep`指令使用，如下面指令，将当前目录`./`下的所有`.txt`文件中的`yyyy`字符串替换为`xxxx`
```bash
sed -i s/yyyy/xxxx/g `grep yyyy -rl --include="*.txt" ./`
```


3、批量kill进程<br>
```bash
ps aux|grep nginx|grep -v grep|awk '{print $2}'|xargs kill -9
```

4、仅替换当前目录下的文件内容<br>
```bash
sed -i s/xxxx/yyyy/g ./*.txt
```

5、在匹配行的位置上面或者下面添加指定内容、删除指定行内容<br>
注意下面`sed`指令替换那列的`a`和`i`这两个参数：

```BASH
sed -i /xxxx/d ./*.txt    #删除命中查询条件的行
sed -i /7777/a77777 ./*.txt #在命中查询条件的下一行添加77777
sed -i /7777/i77777 ./*.txt #在命中查询条件的上一行添加77777
```

6、解析pcap抓包文件<br>
下面示例，通过`tcpdump -r`指令对抓包中的源IP进行TOP统计，并按照数量进行排序
```BASH
tcpdump -r xxxx.pcap |awk '{print $3}'|awk -F '\.' '{print $1"."$2"."$3"."$4}' |sort |uniq -c |sort -nr -k 1
```

7、获取字符串最后一个字符<br>
```bash
STR=123456abc
FINAL=`echo ${STR: -1}`
FINAL_O=${STR: -1}  #与上面等价
FINAL2=`echo ${STR: -2}` #获取最后两个字符
```

8、去掉字符串最后两个字符<br>
```BASH
var="12345467,"
echo ${var%??}
```

9、去掉字符串末尾一个字符<br>
```BASH
var="12345467,"
echo ${var%?}
```

10、`sed`如何处理ascii码为`0`的字符？<br>
```BASH
find . -print0 | sed -e 's/\x0/\n/g'
```
在上例中，`find`命令把当前目录下的文件名输出出来，以`0`字符分隔。输出被管道送给`sed`进行处理。在`sed`中，则把`0`字符替换成回车符


11、`sed`如何使用shell中的变量<br>
如何在`sed`中使用shell定义的变量？要用双引号而不是单引号来引用sed命令，因为shell会处理双引号中的变量引用，而对单引号中的内容，shell完全不会处理
```BASH
TERM1=term; TERM2=rxvt; echo "term" | sed -e "s/$TERM1/$TERM2/g"
```

##  0x02  字符串操作总结

12、字符串不对称分割<br>
如何从指定字符（子字符串）开始截取？

1) 使用 `#` 号截取指定字符（或子字符串）右边字符

```bash
string="xx|xxxxx"
echo ${string#*|} #输出xxxxx

string="xx|123456"
echo ${string#*|123}  #输出456

echo ${string#xx|123} #输出456
```

语法为：
```bash
${string#*chars}
```

其中，`string` 表示要截取的字符，`chars` 是指定的字符（或者子字符串），`*`是通配符的一种，表示任意长度的字符串。`*chars`连起使用的意思是：忽略左边的所有字符，直到遇见 `chars`（`chars` 不会被截取）


2) 匹配到最后一个指定字符再结束，格式串为`${string##*chars}`

```bash
url="http://a.b.c/index.html"
echo ${url#*/}    #输出/a.b.c/index.html
echo ${url##*/}   #输出index.html

str="---aa+++aa@@@"
echo ${str#*aa}   #结果为 +++aa@@@
echo ${str##*aa}  #结果为 @@@
```

3) 使用 `%` 截取指定字符（或者子字符串）左边字符，格式为`${string%chars*}`，注意`*`的位置


```bash
url="http://a.b.c/index.html"
echo ${url%/*}  #http://a.b.c
echo ${url%%/*}  #结果为 http:
str="---aa+++aa@@@"
echo ${str%aa*}  #结果为 ---aa+++
echo ${str%%aa*}  #结果为 ---
```

汇总下：

|匹配格式 | 说明 | 
|:-----:|:----:| 
|${string: start :length}	|从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符|
|${string: start}	|从 string 字符串的左边第 start 个字符开始截取，直到最后|
|${string: 0-start :length}	|从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符|
|${string: 0-start}	|从 string 字符串的右边第 start 个字符开始截取，直到最后|
|${string#*chars}	|从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符|
|${string##*chars}	|从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符|
|${string%*chars}	|从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符|
|${string%%*chars}	|从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符|



13、分割字符串<br>
```bash
IN="bla@some.com;john@home.com"
arrIN=(${IN//;/ })
echo ${arrIN[1]}                  # Output: john@home.com
```

```bash
IFS=';' read -ra ADDR <<< "$IN"
for i in "${ADDR[@]}"; do
   echo "$i"
done
```

```bash
$ echo "bla@some.com;john@home.com" | cut -d ";" -f 1
bla@some.com
$ echo "bla@some.com;john@home.com" | cut -d ";" -f 2
john@home.com
```

##  0x03  参考
- [How do I split a string on a delimiter in Bash?](https://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash)